{
    "author": "Anaren Inc.",
    "categories": [
        "Sensor"
    ],
    "code": {
        "connected": "",
        "global": "",
        "interval": "",
        "setup": "\tINA219_Init();\n"
    },
    "config": {
        "file": "ina219_config.h",
        "values": {}
    },
    "description": "Zero-Drift, Bidirectional Current/Power Monitor With I2C Interface",
    "elements": {},
    "files": {
        "common": {
            "headers": {
                "ina219.h": "#pragma once\n\n#include <stdint.h>\n\n/*=========================================================================\n    CONFIG REGISTER (R/W)\n    -----------------------------------------------------------------------*/\n    #define INA219_REG_CONFIG                      (0x00)\n    /*---------------------------------------------------------------------*/\n    #define INA219_CONFIG_RESET                    (0x8000)  // Reset Bit\n\t\n    #define INA219_CONFIG_BVOLTAGERANGE_MASK       (0x2000)  // Bus Voltage Range Mask\n    #define INA219_CONFIG_BVOLTAGERANGE_16V        (0x0000)  // 0-16V Range\n    #define INA219_CONFIG_BVOLTAGERANGE_32V        (0x2000)  // 0-32V Range\n\t\n    #define INA219_CONFIG_GAIN_MASK                (0x1800)  // Gain Mask\n    #define INA219_CONFIG_GAIN_1_40MV              (0x0000)  // Gain 1, 40mV Range\n    #define INA219_CONFIG_GAIN_2_80MV              (0x0800)  // Gain 2, 80mV Range\n    #define INA219_CONFIG_GAIN_4_160MV             (0x1000)  // Gain 4, 160mV Range\n    #define INA219_CONFIG_GAIN_8_320MV             (0x1800)  // Gain 8, 320mV Range\n\t\n    #define INA219_CONFIG_BADCRES_MASK             (0x0780)  // Bus ADC Resolution Mask\n    #define INA219_CONFIG_BADCRES_9BIT             (0x0080)  // 9-bit bus res = 0..511\n    #define INA219_CONFIG_BADCRES_10BIT            (0x0100)  // 10-bit bus res = 0..1023\n    #define INA219_CONFIG_BADCRES_11BIT            (0x0200)  // 11-bit bus res = 0..2047\n    #define INA219_CONFIG_BADCRES_12BIT            (0x0400)  // 12-bit bus res = 0..4097\n    \n    #define INA219_CONFIG_SADCRES_MASK             (0x0078)  // Shunt ADC Resolution and Averaging Mask\n    #define INA219_CONFIG_SADCRES_9BIT_1S_84US     (0x0000)  // 1 x 9-bit shunt sample\n    #define INA219_CONFIG_SADCRES_10BIT_1S_148US   (0x0008)  // 1 x 10-bit shunt sample\n    #define INA219_CONFIG_SADCRES_11BIT_1S_276US   (0x0010)  // 1 x 11-bit shunt sample\n    #define INA219_CONFIG_SADCRES_12BIT_1S_532US   (0x0018)  // 1 x 12-bit shunt sample\n    #define INA219_CONFIG_SADCRES_12BIT_2S_1060US  (0x0048)\t // 2 x 12-bit shunt samples averaged together\n    #define INA219_CONFIG_SADCRES_12BIT_4S_2130US  (0x0050)  // 4 x 12-bit shunt samples averaged together\n    #define INA219_CONFIG_SADCRES_12BIT_8S_4260US  (0x0058)  // 8 x 12-bit shunt samples averaged together\n    #define INA219_CONFIG_SADCRES_12BIT_16S_8510US (0x0060)  // 16 x 12-bit shunt samples averaged together\n    #define INA219_CONFIG_SADCRES_12BIT_32S_17MS   (0x0068)  // 32 x 12-bit shunt samples averaged together\n    #define INA219_CONFIG_SADCRES_12BIT_64S_34MS   (0x0070)  // 64 x 12-bit shunt samples averaged together\n    #define INA219_CONFIG_SADCRES_12BIT_128S_69MS  (0x0078)  // 128 x 12-bit shunt samples averaged together\n\t\n    #define INA219_CONFIG_MODE_MASK                (0x0007)  // Operating Mode Mask\n    #define INA219_CONFIG_MODE_POWERDOWN           (0x0000)\n    #define INA219_CONFIG_MODE_SVOLT_TRIGGERED     (0x0001)\n    #define INA219_CONFIG_MODE_BVOLT_TRIGGERED     (0x0002)\n    #define INA219_CONFIG_MODE_SANDBVOLT_TRIGGERED (0x0003)\n    #define INA219_CONFIG_MODE_ADCOFF              (0x0004)\n    #define INA219_CONFIG_MODE_SVOLT_CONTINUOUS    (0x0005)\n    #define INA219_CONFIG_MODE_BVOLT_CONTINUOUS    (0x0006)\n    #define INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS (0x0007)\t\n/*=========================================================================*/\n\n/*=========================================================================\n    SHUNT VOLTAGE REGISTER (R)\n    -----------------------------------------------------------------------*/\n    #define INA219_REG_SHUNTVOLTAGE                (0x01)\n/*=========================================================================*/\n\n/*=========================================================================\n    BUS VOLTAGE REGISTER (R)\n    -----------------------------------------------------------------------*/\n    #define INA219_REG_BUSVOLTAGE                  (0x02)\n/*=========================================================================*/\n\n/*=========================================================================\n    POWER REGISTER (R)\n    -----------------------------------------------------------------------*/\n    #define INA219_REG_POWER                       (0x03)\n/*=========================================================================*/\n\n/*=========================================================================\n    CURRENT REGISTER (R)\n    -----------------------------------------------------------------------*/\n    #define INA219_REG_CURRENT                     (0x04)\n/*=========================================================================*/\n\n/*=========================================================================\n    CALIBRATION REGISTER (R/W)\n    -----------------------------------------------------------------------*/\n    #define INA219_REG_CALIBRATION                 (0x05)\n/*=========================================================================*/\n\ntypedef struct ina219_config_t {\n\tuint16_t config_reg_val; /*< Configuration register raw value */\n\tuint16_t calibration_reg_val; /*< Calibration register raw value */\n\tuint16_t current_lsb_ma; /*< LSB of current reading. Used to convert from counts to mA */\n} ina219_config_t;\n\ntypedef enum ina219_result_t {\n\tINA219_SUCCESS = 0,\n\tINA219_INVALID_ADDR = 1,\n\tINA219_I2C_WRITE = 2,\n\tINA219_I2C_READ = 3,\n} ina219_result_t;\n\n/*\n* Initialize INA219\n* - Set Configuration Register\n*\n* NOTE: Default configuration assumed .1 Ohm Shunt. 32V 2A range with current LSB 10mA\n*\n* @param[in] addr - I2C Address of device\n*\n* @return ina219_result_t\n*/\nina219_result_t INA219_Init(uint8_t addr);\n\n/**\n* Write a raw INA219 Register\n*\n* @param[in] addr - I2C Address of device\n* @param[in] reg - register address\n* @param[in] value - value to write\n*/\nina219_result_t INA219_WriteReg(uint8_t addr, uint8_t reg, uint16_t value);\n\n/**\n* Read a raw INA219 Register\n*\n* @param[in] addr - I2C Address of device\n* @param[in] reg - register address\n* @param[out] value - value to read\n*/\nina219_result_t INA219_ReadReg(uint8_t addr, uint8_t reg, uint16_t *value);\n\n/**\n* Set INA219 Configuration\n*\n* Modifies the INA219_REG_CALIBRATION and INA219_REG_CONFIG registers to provide accurate current readings.\n*\n* @param[in] addr - I2C Address of device\n* @param[in] config\n*/\nina219_result_t INA219_SetConfig(uint8_t addr, const ina219_config_t *config);\n\n/**\n* Set INA219 Calibration\n*\n* Modifies the INA219_REG_CALIBRATION register. Read the INA219 datasheet for information on how to determine this value.\n*\n* http://www.ti.com/lit/ds/symlink/ina219.pdf\n*\n* @param[in] addr - I2C Address of device\n* @param[in] value - calculated calibration value\n*/\nina219_result_t INA219_SetCalibration(uint8_t addr, uint16_t value);\n\n/**\n* Get direct reading of INA219_REG_BUSVOLTAGE register\n*\n* @param[in] addr - I2C Address of device\n* @param[out] voltage\n*/\nina219_result_t INA219_GetBusVoltageRaw(uint8_t addr, int16_t *voltage);\n\n/**\n* Get direct reading of INA219_REG_SHUNTVOLTAGE register\n*\n* @param[in] addr - I2C Address of device\n* @param[out] voltage\n*/\nina219_result_t INA219_GetShuntVoltageRaw(uint8_t addr, int16_t *voltage);\n\n/**\n* Get direct reading of INA219_REG_CURRENT register\n*\n* @param[in] addr - I2C Address of device\n* @param[out] current\n*/\nina219_result_t INA219_GetCurrentRaw(uint8_t addr, int16_t *current);\n\n/**\n* Get Shunt Voltage in MilliVolts (mV)\n*\n* @param[in] addr - I2C Address of device\n* @param[out] voltage\n*/\nina219_result_t INA219_GetShuntVoltageMv(uint8_t addr, float *voltage);\n\n/**\n* Get Bus Voltage in Volts (V)\n*\n* @param[in] addr - I2C Address of device\n* @param[out] voltage\n*/\nina219_result_t INA219_GetBusVoltageV(uint8_t addr, float *voltage);\n\n/**\n* Get Current in MilliAmps (mA)\n*\n* @param[in] addr - I2C Address of device\n* @param[out] current\n*/\nina219_result_t INA219_GetCurrentMa(uint8_t addr, float *current);\n"
            },
            "objects": {
                "ina219.c": "#include \"ina219.h\"\n\n#include \"../i2c/i2c.h\"\n#include \"ina219_config.h\"\n#include <stdbool.h>\n\n#define INA219_SLAVE_BASE_ADDR 0x40\n\n#define NUM_IDS 4 // 0x40 through 0x45. Only 0x40, 0x41, 0x44, and 0x45 are actually available\n\nstatic ina219_config_t ina219_config[NUM_IDS] = {0};\n\nstatic int8_t ina219_addr_to_index(uint8_t addr)\n{\n  switch(id)\n  {\n    case 0x40:\n      return 0;\n    case 0x41:\n      return 1;\n    case 0x44:\n      return 2;\n    case 0x45:\n      return 3;\n    default:\n      return -1;\n  }\n}\n\nstatic bool ina219_is_valid_addr(uint8_t addr)\n{\n  return ina219_id_to_index(addr) != -1;\n}\n\nina219_result_t INA219_Init(uint8_t addr)\n{\n  // NOTE: Default configuration assumes .1 Ohm shunt\n  // 32V 2A Range\n  // 10mA LSB for current readings\n  ina219_config_t default_config;\n  default_config.config_reg_val = INA219_CONFIG_BVOLTAGERANGE_32V |\n                    INA219_CONFIG_GAIN_8_320MV |\n                    INA219_CONFIG_BADCRES_12BIT |\n                    INA219_CONFIG_SADCRES_12BIT_1S_532US |\n                    INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS;\n\n  default_config.calibration_reg_val = 4096;\n  default_config.current_lsb_ma = 10;\n  ina219_result_t ret_val = INA219_SetConfig(addr, &default_config );\n  return ret_val;\n}\n\nina219_result_t INA219_WriteReg(uint8_t addr, uint8_t reg, uint16_t value)\n{\n  if( !ina219_is_valid_addr(addr) )\n    return;\n\n  uint8_t writeBytes[3];\n\n  writeBytes[0] = reg;\n  writeBytes[1] = value >> 8;\n  writeBytes[2] = value & 0xFF;\n  AIR_I2C_Write(addr, writeBytes, 3);\n  return INA219_SUCCESS;\n}\n\nina219_result_t INA219_ReadReg(uint8_t addr, uint8_t reg, uint16_t *value)\n{\n  if( !ina219_is_valid_addr(addr) )\n    return 0;\n\n  uint8_t write_bytes[1] = {0};\n  uint8_t read_bytes[2] = {0};\n  uint16_t read_data = 0;\n\n  write_bytes[0] = addr;\n  AIR_I2C_ComboRead(addr, write_bytes, 1, read_bytes, 2);\n  read_data = (unsigned int)read_bytes[0] << 8;\n  read_data |= read_bytes[1];\n  *value = read_data;\n  return INA219_SUCCESS;\n}\n\nina219_result_t INA219_SetConfig(uint8_t addr, const ina219_config_t *config)\n{\n  if( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  ina219_config[ina219_addr_to_index(addr)] = *config;\n  ina219_result_t ret_val = INA219_WriteReg(addr, INA219_REG_CONFIG, config->config_reg_val);\n\n  if( ret_val == INA219_SUCCESS )\n  {\n    ret_val = INA219_SetCalibrationRaw(addr, config->calibration_reg_val);\n  }\n\n  return ret_val;\n}\n\n\nina219_result_t INA219_SetCalibrationRaw(uint8_t addr, uint16_t value)\n{\nif( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  ina219_config[ina219_addr_to_index(addr)].calibration_reg_val = value;\n  return INA219_WriteReg(addr, INA219_REG_CALIBRATION, value);\n}\n\nina219_result_t INA219_GetBusVoltageRaw(uint8_t addr, uin16_t *voltage) {\nif( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  uint16_t value = 0;\n\n  ina219_result_t ret_val = INA219_ReadReg(addr, INA219_REG_BUSVOLTAGE, &value);\n\n  // Shift to the right 3 to drop CNVR and OVF and multiply by LSB\n  *voltage = (int16_t)((value >> 3) * 4);\n\n  return ret_val;\n}\n\nina219_result_t INA219_GetShuntVoltageRaw(uint8_t addr, int16_t *voltage) {\nif( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  return INA219_ReadReg(addr, INA219_REG_SHUNTVOLTAGE, voltage);\n}\n\n/**************************************************************************/\n/*! \n    @brief  Gets the raw current value (16-bit signed integer, so +-32767)\n*/\n/**************************************************************************/\nina219_result_t INA219_GetCurrentRaw(uint8_t addr, int16_t *current) {\nif( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  // Sometimes a sharp load will reset the INA219, which will\n  // reset the cal register, meaning CURRENT and POWER will\n  // not be available ... avoid this by always setting a cal\n  // value even if it's an unfortunate extra step\n  ina219_result_t ret_val = INA219_WriteReg(addr, INA219_REG_CALIBRATION, ina219_calValue);\n\n  if( ret_val == INA219_SUCCESS )\n  {\n    ret_val = INA219_ReadReg(addr, INA219_REG_CURRENT, current);\n  }\n  \n  return ret_val;\n}\n \nina219_result_t INA219_GetShuntVoltageMv(uint8_t addr, float *voltage) {\nif( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  int16_t value;\n  ina219_result_t ret_val = INA219_GetShuntVoltageRaw(addr, &value);\n  *voltage = value * 0.01;\n  return ret_val;\n}\n\nina219_result_t INA219_GetBusVoltageV(uint8_t addr, float *voltage) {\nif( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  int16_t value;\n  ina219_result_t ret_val = INA219_GetBusVoltageRaw(addr, &value);\n  *voltage = value * 0.001;\n  return ret_val;\n}\n\nina219_result_t INA219_GetCurrentMa(uint8_t addr, float *current) {\nif( !ina219_is_valid_addr(addr) )\n    return INA219_INVALID_ADDR;\n\n  int16_t value_dec;\n  ina219_result_t ret_val = INA219_GetCurrentRaw(addr, &value_dec);\n  *current = value_dec / ina219_config[ina219_addr_to_index(addr)].current_lsb_ma;\n  return ret_val;\n}"
            },
            "other": {}
        }
    },
    "label": "INA219 Driver",
    "language": {
        "en": {
            "label": "INA219 Driver"
        }
    },
    "links": {
        "Datasheet": "http://www.ti.com/lit/ds/symlink/ina219.pdf",
        "Product Page": "http://www.ti.com/product/ina219",
        "Wiki Page": "https://atmosphere.anaren.com/wiki/INA219_Driver"
    },
    "manufacturer": "Texas Instruments",
    "name": "ina219",
    "signature": "",
    "type": "Embedded Library",
    "version": "1.0.0"
}